"""Generates a file containing a specification of an action that was run.

The file will contain information such as:
* The features in use
* The args in use
* Which command-line entries are generated by which args
* Environment variables
* Input files
"""

import itertools
import json
import os
import re
import sys

def format_dict(d):
    return "\n".join(f"  {k}={repr(v)}" for k, v in sorted(d.items()))

output_file = sys.argv[1]
args = sys.argv[2:]
arg_groups = []
for arg in sys.argv[2:]:
    if arg == "ARG_SPLITTER":
        arg_groups.append([])
    else:
        arg_groups[-1].append(arg)

arg_labels = [label for label in os.environ["ARGS"].split("\n") if label]

assert len(arg_groups) >= len(arg_labels), (sys.argv, arg_groups, arg_labels)
args_by_label = itertools.zip_longest(arg_labels, arg_groups, fillvalue="Extra action args:")


action = os.environ["ACTION"]
env = json.loads(os.environ["ENV"])
features = os.environ["FEATURES"]
outputs = os.environ["OUTPUTS"]
progress_message = os.environ["PROGRESS_MESSAGE"]
tool = os.environ["TOOL"]
tool_exe = os.environ["TOOL_EXE"]
execution_requirements = json.loads(os.environ["EXECUTION_REQUIREMENTS"])

inputs = []
for dirpath, _, filenames in os.walk("."):
    for filename in filenames:
        inputs.append(f"{dirpath[2:]}/{filename}")

inputs = sorted([
    path for path in inputs if "generate_inputs_file" not in path
])

content = [
    f"Action: {action}",
    f"Tool: {tool} ({tool_exe})",
    f"Progress message: {repr(progress_message)}",
    "\nInputs:\n{}".format("\n".join(inputs)),
    f"\nOutputs:\n{outputs}\n",
    f"Features:\n{features}\n",
    f"Execution requirements:\n{format_dict(execution_requirements)}\n",
    f"Env:\n{format_dict(env)}\n",
    "Command-line:",
]
for arg, group in args_by_label:
    content.append(arg)
    for entry in group:
        content.append(f"  {entry}")

with open(output_file, 'w') as f:
    f.write(re.sub("bazel-out/[^/]*", "bazel-out/<config>", "\n".join(content)))